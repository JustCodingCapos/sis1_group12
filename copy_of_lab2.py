# -*- coding: utf-8 -*-
"""Copy of Lab2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xbTYbDo2MDUwt5drp7zWFvMBfWSPL_ry

### **Lab 2: Introduction to Complex Exponentials**

The goal of this laboratory is to gain familiarity with complex numbers and their use in representing sinusoidal signals as complex exponentials.

**Complex Numbers in Python**


Python can be used to compute complex-valued formulas and also to display the results as a vector or “phasor” diagrams.

Here are some of numpy package complex number functions (remember to import package):

*conj ()*       Complex conjugate

*abs ()*        Magnitude

*angle ()*      Angle (or phase) in radians

*real ()*       Real part

*imag ()*       Imaginary part
*j *        pre-defined as <math>&radic;-1</math>

*x = 3 + 4j*    j sufix defines imaginary constant

exp(1j<math>*</math>theta)  Function for the complex exponential

Each of these functions takes a vector (or matrix) as its input argument and operates on each element of the vector.

To display a complex number as a point in the complex plane you can directly use the provided function `plot_complex`. It can take a single number or a list of complex numbers as input. For instance, to display the complex number 2+1j:
"""

!git clone https://github.com/pzinemanas/sis1lab.git

import numpy as np
from IPython.display import Audio

from sis1lab.util import load_audio, save_audio, plot_signals, plot_complex

z = 2 + 1j
plot_complex(z)

"""And for displaying several complex numbers:"""

z1 = 2 + 1j
z2 = 1j
z3 = -0.5j
plot_complex([z1, z2, z3], name=['z1', 'z2', 'z3'])

"""# **Exercises**

**1. Complex Numbers**

To exercise your understanding of complex numbers, do the following:

1.1. Define $z_1 = -1+j0.3$ and $z_2 = 0.8+j0.7$. Enter these in Python and plot them as points and vectors in the complex plane.
"""

z1 = -1 + 0.3j
z2 = 0.8 + 0.7j
plot_complex([z1,z2])

"""1.2. Compute the conjugate z* and the inverse 1/z for both $z_1$ and $z_2$ and plot the results as vectors in the complex plane."""

conz1 = np.conj(z1)
conz2 = np.conj(z2)
plot_complex([conz1,conz2])


inz1 = 1/z1
inz2 = 1/z2
plot_complex([inz1,inz2])

"""**2. Complex Exponentials**

Now let's work with complex exponentials. In python is very easy to work with these type of signals:
"""

A = 0.8
f0 = 120
fs = 44100
phi = np.pi/2
t = np.arange(0, .1, 1.0/fs)
x = A * np.exp(1j*(2*f0*np.pi*t + phi))

"""Now we can plot the real and imaginary part of this signal:

"""

plot_signals([np.real(x), np.imag(x)], fs, name=['real part', 'imag part'])

"""2.1. Define a complex exponential with the same parameters that those from Lab 1 (Ex 3.1) and plot the real part."""

# Write the code here
A = 0.06
f0 = 1/0.00858
fs = 44100
phi = np.pi/2
t = np.arange(0, 0.1, 1.0/fs)
x = A * np.exp(1j*(2*f0*np.pi*t + phi))

plot_signals(np.real(x), fs, name='real part')

"""**3. Harmonic signals**

Now, we will work with harmonic signals. Until now, we have been working with simple sinusoids signals but most musical instruments sounds are harmonic. This means that they are formed by a sinusoid of the fundamental frequency plus sinusoids with frequencies multiples of it. For instance, we can define the following signal formed by the fundamental frequency plus the second and the third harmonic (note that each wave has a different phase).


"""

f0 = 120
fs = 44100
phi = np.pi/2
t = np.arange(0, 0.1, 1.0/fs)
x = 1.1*np.cos(2*np.pi*f0*t + np.pi/2) + 0.8*np.cos(2*np.pi*2*f0*t) + 0.2*np.cos(2*np.pi*3*f0*t)
plot_signals(x, fs)

"""3.1. Load your reference audio signal and plot some periods (5-10) where the amplitude is stable. For instance see Ex. 2.3 from Lab 1."""

# Write the code here
f0 = 1/0.00858
fs = 44100
phi = np.pi/2
t = np.arange(1, 1.08, 1.0/fs)
x = 1*np.cos(2*np.pi*f0*t + np.pi/2) + 1.71*np.cos(2*np.pi*2*f0*t) + 2.21*np.cos(2*np.pi*3*f0*t)
plot_signals(x, fs)

"""3.2. Now, define a harmonic signal, `y` whose fundamental frequency is the defined in Lab 1. Go step by step adding a new harmonic in each step. Plot both signals (the reference and the synthesized) and try to reproduce the shape of the reference signal.

**Note 1**: in order to have a similar shape, we need to select the amplitudes and phases carefully. One way to do this is to define the harmonic signal as follows:

$$y(t) = \sum_{k=1}^K A_k\cos\left(2\pi kf_0 t + k \phi - (k-1)\pi/2 \right), $$

where $K$ is the number of harmonics, $f_0$ is the fundamental frequency, $A_k$ is the amplitude (weight) of each harmonic and $\phi$ is the phase of the signal (defined in Lab1 Ex 2.4).

**Note 2**:
Define the $A_k$ values relative to the fundamental frequency. This means to define $A_1=1$ and the others less than 1. You can use Audacity to plot the spectrum of the fragment selected of the reference audio and measure the relative amplitudes of the harmonics.

**Note 3**: Normalize the amplitude of the signal by the same amplitude of the reference. For instance, if the amplitude of the reference signal is 0.33, you can normalize the syntesized signal by first dividing by its maximum and then multiplyng by 0.33:

```
y = 0.33 * y / np.amax(y)
```
"""

# Write the code here
A1 = 1
A2 = 0.58
Ak =
K = 4
f0 = 116.54
ϕ = 0.008504
y = Ak * np.cos(np.pi*2*K*f0*t+K*ϕ-(K-1)*(np.pi/2))
print(y)
plot_signals(y, fs)

"""3.3. Listen to the synthtesis and remark what are the main differences between the reference and synthesis."""

Audio(y, rate=fs)

"""[Double click to enter your answer]"""